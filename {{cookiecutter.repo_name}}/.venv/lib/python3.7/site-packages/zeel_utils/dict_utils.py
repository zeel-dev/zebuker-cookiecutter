"""Dictionary helper module"""


def find(f, seq):
    """
    Return first item in sequence where f(item) == True.

    Parameters
    ----------
    f : function
        Function determining match case.

    seq: object
        Object on which to pass to f function.

    Returns
    -------
    obj:
        Instance that matches the case indicated in the f function.

    """
    for item in seq:
        if f(item):
            return item


def _all_keys_of_props_in_dct(dct):
    """
    Returns all keys of belonging to the properties of a dictionary.

    Parameters
    ----------
    dct : dictionary
        Dictionary to iterate properties.

    Returns
    -------
    list:
        Keys of the properties of a dictionary.

    """
    keys = []

    for key, value in dct.items():
        if not isinstance(value, dict) and not isinstance(value, list):
            keys.append(key)
    return keys


def _dict_merge(dct, merge_dct):
    for merge_key, merge_value in merge_dct.items():
        if (merge_key in dct and isinstance(merge_value, dict)):
            _dict_merge(dct[merge_key], merge_value)
        elif (merge_key in dct and isinstance(merge_value, list)):
            # Sort both arrays of dictionaries by the keys of the first
            # dictionary in merge_value
            dct_value = dct[merge_key]
            if len(merge_value):
                first_item = merge_value[0]
                keys = _all_keys_of_props_in_dct(first_item)
                dct_value.sort(
                    key=lambda obj: [
                        str(obj.get(key)) if obj.get(key) else ''
                        for key in keys
                    ]
                )
                merge_value.sort(
                    key=lambda obj: [
                        str(obj.get(key)) if obj.get(key) else ''
                        for key in keys
                    ]
                )
            for index, value in enumerate(merge_value):
                _dict_merge(dct_value[index], merge_value[index])
        else:
            dct[merge_key] = merge_dct[merge_key]


def dict_merge(dct, merge_dct):
    """
    Recursive dict merge. Inspired by :meth:``dict.update()``, instead of
    updating only top-level keys, dict_merge recurses down into dicts nested
    to an arbitrary depth, updating keys. The ``merge_dct`` is merged into
    ``dct``.

    Parameters
    ----------
    dct : dictionary
        dict onto which the merge is executed
    merge_dct : dictionary
        dct merged into dct

    Returns
    -------
    None
    """

    copy_dct = {**dct}
    copy_merge_dct = {**merge_dct}
    _dict_merge(copy_dct, copy_merge_dct)
    return copy_dct
